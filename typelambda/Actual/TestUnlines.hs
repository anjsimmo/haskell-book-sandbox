-- Generated by testgen.sh
module Actual.TestUnlines where
import TypeLambda
import Data.Typeable
import Expected.TestUnlines as E
import System.IO

x :: [(L(V((X,X),()))((L(V(X,X))((V(X,X)),(V(X,X))),(L(V((),()))(L(V(X,X))(L(V((),(),X))(L(V((X,X),()))(Iff,(V((),(),X)),((V(X,X)),(Car,(V((X,X),()))),(((V((),())),(V((),()))),(V(X,X)),(V((),(),X)),(Cdr,(V((X,X),()))))),((L(V(X,()))(Iff,Int,Integer,(V(X,())))),(V((X,X),()))))))))),(L(V((X,X),()))(L(V((),(X,X)))((L(V(X,X))((V(X,X)),(V(X,X))),(L(V((),()))(L(V(X,X))(L(V((),(),X))(L(V((X,X),()))(Iff,(V((),(),X)),((V(X,X)),(Car,(V((X,X),()))),(((V((),())),(V((),()))),(V(X,X)),(V((),(),X)),(Cdr,(V((X,X),()))))),((L(V(X,()))(Iff,Int,Integer,(V(X,())))),(V((X,X),()))))))))),Cons,(V((),(X,X))),(V((X,X),()))))),(),((L(V(X,X))((L(V(X,X))((V(X,X)),(V(X,X))),(L(V((),()))(L(V(X,X))(L(V((),(),X))(L(V((X,X),()))(Iff,(V((),(),X)),((V(X,X)),(Car,(V((X,X),()))),(((V((),())),(V((),()))),(V(X,X)),(V((),(),X)),(Cdr,(V((X,X),()))))),((L(V(X,()))(Iff,Int,Integer,(V(X,())))),(V((X,X),()))))))))),L(V(X,()))(Cons,((V(X,X)),(V(X,())))),())),L(V((),(X,X)))((L(V((X,X),()))(L(V((),(X,X)))((L(V(X,X))((V(X,X)),(V(X,X))),(L(V((),()))(L(V(X,X))(L(V((),(),X))(L(V((X,X),()))(Iff,(V((),(),X)),((V(X,X)),(Car,(V((X,X),()))),(((V((),())),(V((),()))),(V(X,X)),(V((),(),X)),(Cdr,(V((X,X),()))))),((L(V(X,()))(Iff,Int,Integer,(V(X,())))),(V((X,X),()))))))))),Cons,(V((),(X,X))),(V((X,X),()))))),(V((),(X,X))),(Cons,((L(V(X,()))(Plus,(V(X,())),(V(X,())))),(Plus,((L(V(X,()))(Plus,(V(X,())),(V(X,())))),(Plus,Integer,Integer)),Integer)),())),(V((X,X),())))))]
x = []

lam :: Result
lam = eval prims (typeOf x)

main :: IO ()
main = do
  putStrLn "Expected (Haskell): "
  putStrLn $ E.showExpected
  putStrLn "Actual (Lambda): "
  putStrLn $ E.showActual lam
  putStr "Test Result (Haskell ?= Lambda): "
  putStrLn $ show $ E.oracle lam
